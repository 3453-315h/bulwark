import { UserRequest } from '../interfaces/user-request.interface';
import { Response } from 'express';
import { getConnection } from 'typeorm'
import { Assessment } from '../entity/Assessment';
import { validate } from 'class-validator';
import { Vulnerability } from '../entity/Vulnerability';
import { File } from '../entity/File';
import { ProblemLocation } from '../entity/ProblemLocation'
import { Resource } from '../entity/Resource'
const fileUploadController = require('../routes/file-upload.controller');

/**
 * @description get vulnerability by ID
 * @param {UserRequest} req
 * @param {Response} res contains JSON object with the organization data
 * @returns vulnerability data
 */
const getVulnById = async (req: UserRequest, res: Response) => {
    if (!req.params.vulnId) {
        return res.status(400).send('Invalid Vulnerability UserRequest');
    }
    if (isNaN(+req.params.vulnId)) {
        return res.status(400).send('Invalid Vulnerability ID');
    }
    // TODO: Utilize createQueryBuilder to only return screenshot IDs and not the full object
    const vuln = await getConnection().getRepository(Vulnerability).findOne(req.params.vulnId, {
        relations: ['screenshots', 'problemLocations', 'resources']
    });
    if (!vuln) {
        return res.status(404).send('Vulnerability does not exist.');
    }
    res.status(200).json(vuln);
}
/**
 * @description Delete vulnerability by ID
 * @param {UserRequest} req vulnID is required
 * @param {Response} res contains JSON object with the success/fail
 * @returns success/error message
 */
const deleteVulnById = async (req: UserRequest, res: Response) => {
    if (!req.params.vulnId) {
        return res.status(400).send('Invalid vulnerability UserRequest');
    }
    if (isNaN(+req.params.vulnId)) {
        return res.status(400).send('Invalid vulnerability ID');
    }
    const vuln = await getConnection().getRepository(Vulnerability).findOne(req.params.vulnId);
    if (!vuln) {
        return res.status(404).send('Vulnerability does not exist.');
    } else {
        await getConnection().getRepository(Vulnerability).delete(vuln);
        res.status(200).json('Vulnerability successfully deleted');
    }
}
/**
 * @description Update vulnerability by ID
 * @param {UserRequest} req
 * @param {Response} res
 * @returns success/error message
 * // TODO: Break apart this function into smaller functions.  Also make common as create is almost the same.
 */
const patchVulnById = async (req: UserRequest, res: Response) => {
    req = await fileUploadController.uploadFileArray(req, res);
    if (isNaN(+req.body.assessment) || !req.body.assessment) {
        return res.status(400).json('Invalid Assessment ID');
    }
    const assessment = await getConnection().getRepository(Assessment).findOne(req.body.assessment);
    if (!assessment) {
        return res.status(404).json('Assessment does not exist');
    }
    if (isNaN(+req.params.vulnId)) {
        return res.status(400).json('Vulnerability ID is invalid');
    }
    const vulnerability = await getConnection().getRepository(Vulnerability).findOne(req.params.vulnId);
    if (!vulnerability) {
        return res.status(404).json('Vulnerability does not exist');
    }
    vulnerability.id = +req.params.vulnId;
    vulnerability.impact = req.body.impact;
    vulnerability.likelihood = req.body.likelihood;
    vulnerability.risk = req.body.risk;
    vulnerability.status = req.body.status;
    vulnerability.description = req.body.description;
    vulnerability.remediation = req.body.remediation;
    vulnerability.jiraId = req.body.jiraId;
    vulnerability.cvssScore = req.body.cvssScore;
    vulnerability.cvssUrl = req.body.cvssUrl;
    vulnerability.detailedInfo = req.body.detailedInfo;
    vulnerability.assessment = assessment;
    vulnerability.name = req.body.name;
    vulnerability.systemic = req.body.systemic;
    const errors = await validate(vulnerability);
    if (errors.length > 0) {
        return res.status(400).send('Vulnerability form validation failed');
    } else {
        await getConnection().getRepository(Vulnerability).save(vulnerability);
        // Remove deleted files
        if (req.body.screenshotsToDelete) {
            const existingScreenshots = await getConnection().getRepository(File)
                .find({ where: { vulnerability: vulnerability.id } });
            const existingScreenshotIds = existingScreenshots.map(screenshot => screenshot.id);
            let screenshotsToDelete = JSON.parse(req.body.screenshotsToDelete);
            // We only want to remove the files associated to the vulnerability
            screenshotsToDelete = existingScreenshotIds.filter(value => screenshotsToDelete.includes(value));
            for (const screenshotId of screenshotsToDelete) {
                getConnection().getRepository(File).delete(screenshotId);
            }
        }
        // Save new files added
        for (const screenshot of req.files) {
            let file = new File();
            file = screenshot;
            file.vulnerability = vulnerability;
            const fileErrors = await validate(file)
            if (fileErrors.length > 0) {
                return res.status(400).send('File validation failed');
            } else {
                await getConnection().getRepository(File).save(file);
            }
        }
        // Remove deleted problem locations
        if (req.body.problemLocations.length) {
            const clientProdLocs = JSON.parse(req.body.problemLocations);
            const clientProdLocsIds = clientProdLocs.map(value => value.id);
            const existingProbLocs = await getConnection().getRepository(ProblemLocation)
                .find({ where: { vulnerability: vulnerability.id } });
            const existingProbLocIds = existingProbLocs.map(probLoc => probLoc.id);
            const prodLocsToDelete = existingProbLocIds.filter(value => !clientProdLocsIds.includes(value));
            for (const probLoc of prodLocsToDelete) {
                getConnection().getRepository(ProblemLocation).delete(probLoc);
            }
            // Update problem locations
            for (const probLoc of clientProdLocs) {
                if (probLoc && probLoc.location && probLoc.target) {
                    let problemLocation = new ProblemLocation();
                    problemLocation = probLoc;
                    problemLocation.vulnerability = vulnerability;
                    const plErrors = await validate(problemLocation);
                    if (plErrors.length > 0) {
                        return res.status(400).send('Problem Location validation failed');
                    } else {
                        await getConnection().getRepository(ProblemLocation).save(problemLocation);
                    }
                } else {
                    return res.status(400).send('Invalid Problem Location');
                }
            }
        }
        // Remove deleted resources
        if (req.body.resources.length) {
            const clientResources = JSON.parse(req.body.resources);
            const clientResourceIds = clientResources.map(value => value.id);
            const existingResources = await getConnection().getRepository(Resource)
                .find({ where: { vulnerability: vulnerability.id } });
            const existingResourceIds = existingResources.map(resource => resource.id);
            const resourcesToDelete = existingResourceIds.filter(value => !clientResourceIds.includes(value));
            for (const resource of resourcesToDelete) {
                getConnection().getRepository(Resource).delete(resource);
            }
            // Update resources
            for (const clientResource of clientResources) {
                if (clientResource.description && clientResource.url) {
                    let resource = new Resource();
                    resource = clientResource;
                    resource.vulnerability = vulnerability;
                    const resourceErrors = await validate(resource);
                    if (resourceErrors.length > 0) {
                        return res.status(400).send('Resource Location validation failed');
                    } else {
                        await getConnection().getRepository(Resource).save(resource);
                    }
                } else {
                    return res.status(400).send('Resource Location Invalid');
                }
            }
        }
        return res.status(200).json('Vulnerability patched successfully');
    }
}
/**
 * @description Create vulnerability
 * @param {UserRequest} req
 * @param {Response} res
 * @returns success/error message
 */
const createVuln = async (req: UserRequest, res: Response) => {
    req = await fileUploadController.uploadFileArray(req, res);
    if (isNaN(+req.body.assessment) || !req.body.assessment) {
        return res.status(400).json('Invalid Assessment ID');
    }
    const assessment = await getConnection().getRepository(Assessment).findOne(req.body.assessment);
    if (!assessment) {
        return res.status(404).json('Assessment does not exist');
    }
    const vulnerability = new Vulnerability();
    vulnerability.impact = req.body.impact;
    vulnerability.likelihood = req.body.likelihood;
    vulnerability.risk = req.body.risk;
    vulnerability.status = req.body.status;
    vulnerability.description = req.body.description;
    vulnerability.remediation = req.body.remediation;
    vulnerability.jiraId = req.body.jiraId;
    vulnerability.cvssScore = req.body.cvssScore;
    vulnerability.cvssUrl = req.body.cvssUrl;
    vulnerability.detailedInfo = req.body.detailedInfo;
    vulnerability.assessment = assessment;
    vulnerability.name = req.body.name;
    vulnerability.systemic = req.body.systemic;
    const errors = await validate(vulnerability);
    if (errors.length > 0) {
        return res.status(400).send('Vulnerability form validation failed');
    } else {
        await getConnection().getRepository(Vulnerability).save(vulnerability);
        // Save screenshots
        for (const screenshot of req.files) {
            let file = new File();
            file = screenshot;
            file.vulnerability = vulnerability;
            const fileErrors = await validate(file);
            if (fileErrors.length > 0) {
                return res.status(400).send('File validation failed');
            } else {
                await getConnection().getRepository(File).save(file);
            }
        }
        // Save problem locations
        const problemLocations = JSON.parse(req.body.problemLocations);
        for (const probLoc of problemLocations) {
            if (probLoc && probLoc.location && probLoc.target) {
                let problemLocation = new ProblemLocation();
                problemLocation = probLoc;
                problemLocation.vulnerability = vulnerability;
                const plErrors = await validate(problemLocation);
                if (plErrors.length > 0) {
                    return res.status(400).send('Problem Location validation failed');
                } else {
                    await getConnection().getRepository(ProblemLocation).save(problemLocation);
                }
            } else {
                return res.status(400).send('Invalid Problem Location');
            }
        }
        // Save Resource Locations
        const resources = JSON.parse(req.body.resources);
        for (const resource of resources) {
            if (resource.description && resource.url) {
                let newResource = new Resource();
                newResource = resource;
                newResource.vulnerability = vulnerability;
                const nrErrors = await validate(newResource);
                if (nrErrors.length > 0) {
                    return res.status(400).send('Resource Location validation failed');
                } else {
                    await getConnection().getRepository(Resource).save(newResource);
                }
            } else {
                return res.status(400).send('Resource Location Invalid');
            }
        }
        res.status(200).json('Vulnerability saved successfully');
    }
}

module.exports = {
    getVulnById,
    deleteVulnById,
    patchVulnById,
    createVuln
}